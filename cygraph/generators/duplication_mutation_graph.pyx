# cython: cdivision = True

from ..graph cimport assert_normalized_node_labels, count_t, Graph, node_t, node_list_t
from ..libcpp.random cimport bernoulli_distribution, binomial_distribution, mt19937, \
    uniform_int_distribution
from ..util import assert_interval
from .util cimport get_random_engine



def duplication_mutation_graph(n: int, deletion_proba: float, mutation_proba: float = 0,
                                 graph: Graph = None, random_engine=None) -> Graph:
    r"""
    Duplication divergence graph with random mutations as described by [Sole2002]_.

    Args:
        n: Number of nodes.
        deletion_proba: Probability that a duplicated edge is deleted (:math:`\delta` in
            [Sole2002]_).
        mutation_proba: Scaled mutation probability (:math:`\beta` in [Sole2002]_) such that
            connections between the new node and existings nodes are created with probability
            :math:`\min\left(1, \beta / t\right)`.
        graph: Seed graph; defaults to a pair of connected nodes.
        random_engine: See :func:`get_random`_engine`.

    Returns:
        graph: Graph generated by the duplication divergence model.

    The growth process proceeds in four stages at each step :math:`t`:

    1. A node :math:`i` is chosen at random and duplicated to obtain a new node :math:`t`.
    2. For each neighbor :math:`j` of :math:`i`, a connection to the new node :math:`t` is added
       with probability :math:`1 - \delta`.
    3. Connections between the new node :math:`t` and any other nodes in the network are created
       with probability :math:`\min\left(1, \beta / t\right)`.
    4. Discard the new node :math:`t` if it does not have any edges. This ensures the graph remains
       connected and is adapted from [Ispolatov2005]_. Indeed, setting :math:`\beta = 0` reduces to
       Ispolatov's model and is equivalent to
       :func:`networkx.generators.duplication.duplication_divergence_graph`.

    Note:
        In the third step, we sample the number of additional edges :math:`k` from a binomial random
        variable with :math:`t - 1` trials and probability :math:`\min\left(1, \beta / t\right)`. We
        then sample :math:`k` neighbors with replacement and connect them to :math:`t`. The actual
        number of additional connections may thus be smaller than :math:`k`, especially when the
        graph is small. This compromise avoids relatively expensive sampling without replacement
        from the population of nodes.

    .. [Ispolatov2005] I. Ispolatov, P. L. Krapivsky, and A. Yuryev. Duplication-divergence model of
       protein interaction network. *Phys. Rev. E*, 71(6):061911, 2005.
       https://doi.org/10.1103/PhysRevE.71.061911
    .. [Sole2002] R. V. Sol ÃÅe, R. Pastor-Satorras, E. Smith, and T. B. Kepler. A model of
       large-scale proteome evolution. Adv. Complex Syst., 5(1):43--54, 2002.
       https://doi.org/10.1142/S021952590200047X

    .. plot::

       plot_graph(generators.duplication_mutation_graph(20, 0.6, 0.2))
    """
    cdef bernoulli_distribution deletion_dist = bernoulli_distribution(deletion_proba)
    cdef binomial_distribution[count_t] num_additional_neighbors_dist
    cdef count_t num_additional_neighbors
    cdef uniform_int_distribution[node_t] random_node_dist
    cdef node_list_t additional_neighbors
    cdef node_t new_node, random_neighbor, seed_node
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("n", n, 2, None)
    assert_interval("deletion_proba", deletion_proba, 0, 1, inclusive_high=False)
    assert_interval("mutation_proba", mutation_proba, 0, None)

    if not graph:
        graph = Graph()
        graph.add_edge(0, 1)
    assert_normalized_node_labels(graph)

    while graph.number_of_nodes() < n:
        new_node = graph.number_of_nodes()
        # Choose a random node from current graph to duplicate.
        random_node_dist = uniform_int_distribution[node_t](0, new_node - 1)
        seed_node = random_node_dist(random_engine_instance)
        # Relatively cheap check to avoid constructing distributions if we don't need them.
        if mutation_proba > 0:
            # Identify nodes connected by random mutation.
            num_additional_neighbors_dist = binomial_distribution[count_t](
                new_node - 1, min(mutation_proba / new_node, 1))
            num_additional_neighbors = num_additional_neighbors_dist(random_engine_instance)
            additional_neighbors.clear()
            for _ in range(num_additional_neighbors):
                additional_neighbors.push_back(random_node_dist(random_engine_instance))
        # Duplicate links independently with the given probability.
        for neighbor in graph._adjacency_map[seed_node]:
            if not deletion_dist(random_engine_instance):
                graph.add_edge(new_node, neighbor)

        for neighbor in additional_neighbors:
            graph.add_edge(new_node, neighbor)
    return graph
