from ..graph cimport assert_normalized_node_labels, count_t, Graph, node_t, node_list_t, node_set_t
from ..libcpp.algorithm cimport sample
from ..libcpp.random cimport bernoulli_distribution, mt19937, uniform_int_distribution
from libcpp.utility cimport move
from ..util import assert_interval
from .util cimport get_random_engine


IF DEBUG_LOGGING:
    import logging
    LOGGER = logging.getLogger()


def surfer_graph(num_nodes: count_t, connection_proba: float, graph: Graph = None,
                 random_engine=None) -> Graph:
    """
    Random surfer graph obtained by exploring the neighborhood of a seed node using a random walk
    and connecting to nodes in the process.

    Args:
        num_nodes: Number of nodes.
        connection_proba: Probability of connecting to a candidate node at each step.
        graph: Seed graph; defaults to a graph with a single node.
        random_engine: See :func:`get_random`_engine`.

    Returns:
        graph: Graph generated by the surfer model.

    .. [Vazquez2003] A. Vazquez. Growing network with local rules: Preferential attachment,
       clustering hierarchy, and degree correlations. *Phys. Rev. E*, 67(5):056104, 2003.
       https://doi.org/10.1103/PhysRevE.67.056104

    .. plot::

       plot_graph(generators.surfer_graph(20, 0.6))
    """
    cdef uniform_int_distribution[node_t] random_node_dist
    cdef bernoulli_distribution connection_dist = bernoulli_distribution(connection_proba)
    cdef node_t new_node, seed_node, neighbor
    cdef node_set_t* ptr
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("num_nodes", num_nodes, 1, None)
    assert_interval("connection_proba", connection_proba, 0, 1)

    if graph is None:
        graph = Graph()
        graph.add_node(0)
    assert_normalized_node_labels(graph)

    while graph.number_of_nodes() < num_nodes:
        new_node = graph.number_of_nodes()
        random_node_dist = uniform_int_distribution[node_t](0, new_node - 1)
        seed_node = random_node_dist(random_engine_instance)
        while True:
            # First identify the neighbor to connect to so we don't accidentally sample the new node
            # itself.
            neighbor = -1
            if connection_dist(random_engine_instance):
                # Surf if there is at least one other neighbor.
                ptr = &graph._adjacency_map[seed_node]
                if ptr.size() > 1:
                    sample(ptr.begin(), ptr.end(), &neighbor, 1, move(random_engine_instance))

            # Stop if we don't create a new edge (we've back-tracked) or if there's no new neighbor.
            if not graph.add_edge(seed_node, new_node) or neighbor == -1:
                break
            seed_node = neighbor

    return graph
