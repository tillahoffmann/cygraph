# cython: cdivision = True

from .graph cimport assert_normalized_node_labels, count_t, Graph, node_t, node_list_t, node_set_t
from .libcpp.algorithm cimport sample
from .libcpp.random cimport bernoulli_distribution, binomial_distribution, mt19937, random_device, \
    uniform_int_distribution, uniform_real_distribution
from libc cimport math
from libcpp.utility cimport move
import numbers
import os
from .util import assert_interval
import typing


IF DEBUG_LOGGING:
    import logging
    LOGGER = logging.getLogger()


cdef class RandomEngine:
    """
    Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits.

    Args:
        seed: Random number generator seed; defaults to a call to
            `random_device <https://en.cppreference.com/w/cpp/numeric/random/random_device>`_.
    """
    cdef mt19937 instance

    def __init__(self, seed: int = None):
        cdef random_device rd
        seed = os.environ.get("SEED") if seed is None else seed
        if seed is None:
            self.instance = mt19937(rd())
        else:
            self.instance = mt19937(int(seed))

    def __call__(self):
        return self.instance()


cpdef RandomEngine get_random_engine(arg: typing.Optional[typing.Union[int, RandomEngine]] = None):
    """
    Utility function to get a random engine.

    Args:
        arg: One of `None`, an integer seed, or a :class:`RandomEngine`. If `None`, a default,
            global random engine is returned. If an integer seed, a newly seeded random engine is
            returned. If a :class:`RandomEngine`, it is passed through.

    Returns:
        random_engine: Initialized :class:`RandomEngine` instance.
    """
    if arg is None:
        return DEFAULT_RANDOM_ENGINE
    elif isinstance(arg, RandomEngine):
        return arg
    elif isinstance(arg, numbers.Integral):
        return RandomEngine(arg)
    else:
        raise ValueError(arg)


DEFAULT_RANDOM_ENGINE = RandomEngine()


def duplication_mutation_graph(n: int, deletion_proba: float, mutation_proba: float = 0,
                                 graph: Graph = None, random_engine=None) -> Graph:
    r"""
    Duplication divergence graph with random mutations as described by [Sole2002]_.

    Args:
        n: Number of nodes.
        deletion_proba: Probability that a duplicated edge is deleted (:math:`\delta` in
            [Sole2002]_).
        mutation_proba: Scaled mutation probability (:math:`\beta` in [Sole2002]_) such that
            connections between the new node and existings nodes are created with probability
            :math:`\min\left(1, \beta / t\right)`.
        graph: Seed graph; defaults to a pair of connected nodes.
        random_engine: See :func:`get_random`_engine`.

    Returns:
        graph: Graph generated by the duplication divergence model.

    The growth process proceeds in four stages at each step :math:`t`:

    1. A node :math:`i` is chosen at random and duplicated to obtain a new node :math:`t`.
    2. For each neighbor :math:`j` of :math:`i`, a connection to the new node :math:`t` is added
       with probability :math:`1 - \delta`.
    3. Connections between the new node :math:`t` and any other nodes in the network are created
       with probability :math:`\min\left(1, \beta / t\right)`.
    4. Discard the new node :math:`t` if it does not have any edges. This ensures the graph remains
       connected and is adapted from [Ispolatov2005]_. Indeed, setting :math:`\beta = 0` reduces to
       Ispolatov's model and is equivalent to
       :func:`networkx.generators.duplication.duplication_divergence_graph`.

    Note:
        In the third step, we sample the number of additional edges :math:`k` from a binomial random
        variable with :math:`t - 1` trials and probability :math:`\min\left(1, \beta / t\right)`. We
        then sample :math:`k` neighbors with replacement and connect them to :math:`t`. The actual
        number of additional connections may thus be smaller than :math:`k`, especially when the
        graph is small. This compromise avoids relatively expensive sampling without replacement
        from the population of nodes.

    .. [Ispolatov2005] I. Ispolatov, P. L. Krapivsky, and A. Yuryev. Duplication-divergence model of
       protein interaction network. *Phys. Rev. E*, 71(6):061911, 2005.
       https://doi.org/10.1103/PhysRevE.71.061911
    .. [Sole2002] R. V. Sol ÃÅe, R. Pastor-Satorras, E. Smith, and T. B. Kepler. A model of
       large-scale proteome evolution. Adv. Complex Syst., 5(1):43--54, 2002.
       https://doi.org/10.1142/S021952590200047X

    .. plot::

       plot_graph(generators.duplication_mutation_graph(20, 0.6, 0.2))
    """
    cdef bernoulli_distribution deletion_dist = bernoulli_distribution(deletion_proba)
    cdef binomial_distribution[count_t] num_additional_neighbors_dist
    cdef count_t num_additional_neighbors
    cdef uniform_int_distribution[node_t] random_node_dist
    cdef node_list_t additional_neighbors
    cdef node_t new_node, random_neighbor, seed_node
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("n", n, 2, None)
    assert_interval("deletion_proba", deletion_proba, 0, 1, inclusive_high=False)
    assert_interval("mutation_proba", mutation_proba, 0, None)

    if not graph:
        graph = Graph()
        graph.add_edge(0, 1)
    assert_normalized_node_labels(graph)

    while graph.number_of_nodes() < n:
        new_node = graph.number_of_nodes()
        # Choose a random node from current graph to duplicate.
        random_node_dist = uniform_int_distribution[node_t](0, new_node - 1)
        seed_node = random_node_dist(random_engine_instance)
        # Relatively cheap check to avoid constructing distributions if we don't need them.
        if mutation_proba > 0:
            # Identify nodes connected by random mutation.
            num_additional_neighbors_dist = binomial_distribution[count_t](
                new_node - 1, min(mutation_proba / new_node, 1))
            num_additional_neighbors = num_additional_neighbors_dist(random_engine_instance)
            additional_neighbors.clear()
            for _ in range(num_additional_neighbors):
                additional_neighbors.push_back(random_node_dist(random_engine_instance))
        # Duplicate links independently with the given probability.
        for neighbor in graph._adjacency_map[seed_node]:
            if not deletion_dist(random_engine_instance):
                graph.add_edge(new_node, neighbor)

        for neighbor in additional_neighbors:
            graph.add_edge(new_node, neighbor)
    return graph


def duplication_complementation_graph(n: int, deletion_proba: float, interaction_proba,
                                      graph: Graph = None, random_engine=None) -> Graph:
    r""""
    Duplication divergence graph with complementation as described by [Vazquez2003]_.

    Args:
        n: Number of nodes.
        deletion_proba: Probability that a duplicated or original edge is deleted (:math:`q` in
            [Vazquez2003]_).
        interaction_proba: Probability that the original and duplicated node are connected
            (:math:`p` in [Vazquez2003]_)
        graph: Seed graph; defaults to a pair of connected nodes.
        random_engine: See :func:`get_random_engine`.

    The growth process proceeds in four stages at each step :math:`t`:

    1. A node :math:`i` is chosen at random and duplicated to obtain a new node :math:`t`, including
       its connections.
    2. For each neighbors :math:`j`, we choose one of the edges :math:`(i, j)` and :math:`(t, j)`
       and remove it with probability `deletion_proba`. I.e., we remove at most one of the edges.
    3. The nodes :math:`i` and :math:`t` are connected with probability `interaction_proba`.
    4. Discard the new node :math:`t` if it does not have any edges. This makes it more likely but
       cannot guarantee that the graph is connected. The strategy is adpated from [Ispolatov2005]_
       who considered a simpler model without edge deletion. See :func:`duplication_mutation_graph`
       for further details.

    .. [Ispolatov2005] I. Ispolatov, P. L. Krapivsky, and A. Yuryev. Duplication-divergence model of
       protein interaction network. *Phys. Rev. E*, 71(6):061911, 2005.
       https://doi.org/10.1103/PhysRevE.71.061911
    .. [Vazquez2003] A. Vazquez, A. Flammini, A. Maritan, and A. Vespignani. Modeling of protein
       interaction networks. *Complexus*, 1(1):38--44, 2003. https://doi.org/10.1159/000067642

    .. plot::

       plot_graph(generators.duplication_complementation_graph(20, 0.6, 0.2))
    """
    # Whether to delete one of the connections.
    cdef bernoulli_distribution deletion_dist = bernoulli_distribution(deletion_proba)
    # Whether to delete the connection with the original node.
    cdef bernoulli_distribution original_dist = bernoulli_distribution(0.5)
    # Whether to create a connection between the original and new node.
    cdef bernoulli_distribution interaction_dist = bernoulli_distribution(interaction_proba)
    cdef uniform_int_distribution[node_t] random_node_dist
    cdef node_t new_node, seed_node
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("n", n, 2, None)
    assert_interval("deletion_proba", deletion_proba, 0, 1, inclusive_high=False)
    assert_interval("interaction_proba", interaction_proba, 0, 1)
    random_engine = get_random_engine(random_engine)

    if not graph:
        graph = Graph()
        graph.add_edge(0, 1)
    assert_normalized_node_labels(graph)

    while graph.number_of_nodes() < n:
        new_node = graph.number_of_nodes()
        # Choose a random node from the current graph to duplicate. We may need to sample multiple
        # times if one of the nodes was deleted due to being disconnected. This may be costly if the
        # deletion probability is high and the interaction probability is low.
        random_node_dist = uniform_int_distribution[node_t](0, new_node - 1)
        while True:
            seed_node = random_node_dist(random_engine_instance)
            if graph.has_node(seed_node):
                break
        IF DEBUG_LOGGING:
            LOGGER.info("selected seed %d for new node %d", seed_node, new_node)

        # Duplicate edges and deal with deletion.
        for neighbor in graph._adjacency_map[seed_node]:
            if deletion_dist(random_engine_instance):  # Delete one of the edges.
                if original_dist(random_engine_instance):  # Delete the old and create the new edge.
                    graph.remove_edge(seed_node, neighbor)
                    graph.add_edge(new_node, neighbor)
                    IF DEBUG_LOGGING:
                        LOGGER.info("deleted old edge %s; created new edge %s",
                                    (seed_node, neighbor), (new_node, neighbor))
                else:  # Keep the old and don't create the new edge.
                    IF DEBUG_LOGGING:
                        LOGGER.info("did not created new edge %s", (new_node, neighbor))
            else:  # Create the new edge.
                graph.add_edge(new_node, neighbor)
                IF DEBUG_LOGGING:
                    LOGGER.info("created new edge %s", (new_node, neighbor))

        # Add interaction.
        if interaction_dist(random_engine_instance):
            graph.add_edge(seed_node, new_node)
            IF DEBUG_LOGGING:
                LOGGER.info("created complementation edge %s", (seed_node, new_node))
        else:
            IF DEBUG_LOGGING:
                LOGGER.info("did not create complementation edge %s", (seed_node, new_node))

    return graph


# This generator is currently commented out because it behaves strangely (see TODO note below).
# def fast_gnp_random_graph(int n, float p, Graph graph = None, RandomEngine random_engine = None) \
#         -> Graph:
#     cdef uniform_real_distribution[float] uniform = uniform_real_distribution[float](0, 1)
#     cdef node_t v, w
#     cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
#     assert_interval("p", p, 0, 1)
#     assert_interval("n", n, 1, None)
#
#     if not graph:
#         graph = Graph()
#     for i in range(n):
#         graph.add_node(i)
#
#     lp = math.log1p(-p)
#
#     v = 1
#     w = -1
#     while v < n:
#         # TODO: why does this behaves different from random.random and is sometimes *really* slow?
#         lr = math.log1p(-uniform(random_engine_instance))
#         w = w + 1 + <node_t>math.floor(lr / lp)
#         while w >= v and v < n:
#             w = w - v
#             v = v + 1
#         if v < n:
#             graph.add_edge(v, w)
#     return graph


# `n` needs a C-style type declaration here for typing to work; not sure why.
def gnp_random_graph(int n, p: float, graph: Graph = None, random_engine=None) -> Graph:
    r"""
    Erdos-Renyi or :math:`G(n, p)` graph. See
    :func:`networkx.generators.random_graphs.gnp_random_graph` for details.

    Args:
        n: Number of nodes.
        p: Probability to create an edge between any pair nodes.
        graph: Seed graph; defaults to the empty graph.
        random_engine: See :func:`get_random`_engine`.

    Returns:
        graph: Graph generated by the :math:`G(n, p)` model.

    .. plot::

       plot_graph(generators.gnp_random_graph(20, 0.1))
    """
    cdef bernoulli_distribution create_edge = bernoulli_distribution(p)
    cdef node_t u, v
    cdef bint added
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("p", p, 0, 1)
    assert_interval("n", n, 1, None)

    graph = assert_normalized_node_labels(graph or Graph())

    for u in range(n):
        graph.add_node(u)
        for v in range(u + 1, n):
            if create_edge(random_engine_instance):
                graph.add_edge(u, v)

    return graph


def redirection_graph(n: count_t, p: float, m: count_t, graph: Graph = None, random_engine=None) \
        -> Graph:
    """
    Redirection graph obtained by selecting random nodes and probabilistically redirecting to their
    neighbors before forming a connection.

    Args:
        n: Number of nodes.
        p: Redirection probability.
        m: Number of stubs for each new node.
        graph: Seed graph; defaults to a graph with a single node.
        random_engine: See :func:`get_random`_engine`.

    Returns:
        graph: Graph generated by the redirection model.

    Note:
        For performance reasons, we sample both candidate nodes (before possible redirection) and
        nodes after redirection with replacement. The realized number of connections for a new node
        may thus be less than :math:`m`.

        This generator is equivalent to the model proposed by [Krapivsky2001]_ implemented by
        :func:`networkx.generators.random_graphs.gnr_graph` if :math:`m = 1`.

    .. [Krapivsky2001] P. L. Krapivsky and S. Redner. Organization of growing random networks.
       *Phys. Rev. E*, 63(6):066123, 2001. https://doi.org/10.1103/PhysRevE.63.066123

    .. plot::

       plot_graph(generators.redirection_graph(20, 0.9, 2))
    """
    cdef uniform_int_distribution[node_t] random_node_dist
    cdef bernoulli_distribution redirection_dist = bernoulli_distribution(p)
    cdef node_t new_node, neighbor
    cdef node_set_t* ptr
    cdef node_list_t neighbors
    cdef mt19937 random_engine_instance = get_random_engine(random_engine).instance
    assert_interval("n", n, 1, None)
    assert_interval("p", p, 0, 1)
    assert_interval("m", m, 1, None)

    if graph is None:
        graph = Graph()
        graph.add_node(0)
    assert_normalized_node_labels(graph)

    while graph.number_of_nodes() < n:
        # Generate the sequence of neighbors by sampling seeds and redirecting proabilistically.
        new_node = graph.number_of_nodes()
        random_node_dist = uniform_int_distribution[node_t](0, new_node - 1)
        neighbors.clear()
        for _ in range(m):
            neighbor = random_node_dist(random_engine_instance)
            if redirection_dist(random_engine_instance):
                ptr = &graph._adjacency_map[neighbor]
                if ptr.size():
                    sample(ptr.begin(), ptr.end(), &neighbor, 1, move(random_engine_instance))
            neighbors.push_back(neighbor)
        # Add the new edges.
        for neighbor in neighbors:
            graph.add_edge(new_node, neighbor)

    return graph
